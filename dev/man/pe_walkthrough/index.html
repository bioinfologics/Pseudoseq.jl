<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Paired end reads · Pseudoseq.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../index.html"><img class="logo" src="../../assets/logo.png" alt="Pseudoseq.jl logo"/></a><h1>Pseudoseq.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">User manual</span><ul><li><a class="toctext" href="../introduction/">Introduction</a></li><li><span class="toctext">Walkthroughs</span><ul><li class="current"><a class="toctext" href>Paired end reads</a><ul class="internal"><li><a class="toctext" href="#Creating-the-universe-1">Creating the universe</a></li><li><a class="toctext" href="#Fragmenting-the-molecules-1">Fragmenting the molecules</a></li><li><a class="toctext" href="#Subsampling-the-molecules-1">Subsampling the molecules</a></li><li><a class="toctext" href="#Creating-the-reads-1">Creating the reads</a></li><li><a class="toctext" href="#Generate-FASTQ-files-1">Generate FASTQ files</a></li></ul></li><li><a class="toctext" href="../se_walkthrough/">Long single end reads</a></li><li><a class="toctext" href="../tg_walkthrough/">Tagged paired end reads</a></li></ul></li><li><span class="toctext">API</span><ul><li><a class="toctext" href="../../api/universe/">Universe</a></li><li><a class="toctext" href="../../api/reads/">Reads</a></li></ul></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>User manual</li><li>Walkthroughs</li><li><a href>Paired end reads</a></li></ul><a class="edit-page" href="https://github.com/bioinfologics/Pseudoseq.jl/blob/master/docs/src/man/pe_walkthrough.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Paired end reads</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Walkthrough:-paired-end-reads-1" href="#Walkthrough:-paired-end-reads-1">Walkthrough: paired end reads</a></h1><h2><a class="nav-anchor" id="Creating-the-universe-1" href="#Creating-the-universe-1">Creating the universe</a></h2><p>All DNA sequencing experiments begin with a sample of tissue or cells. Some hair, some blood and so forth.</p><p>Such a sample undergoes a DNA extraction preparation in the laboratory, after which the genome exists as number of DNA molecules, suspended in a solution.</p><p>Many cells are typically used as raw input material for DNA extraction, and so the extracted DNA material contains a great many copies of the genome.</p><p>In <code>Pseudoseq</code>, we call this extracted genetic material (or rather the abstraction of it) <em>the universe</em>. So named, as it is the totality of all copies of the genome that exist in your simulation, from which all subsequent library prep will be done, and from which all reads will be sequenced.</p><p><code>Pseudoseq</code> abstracts DNA sequencing experiments as sampling processes, because this is what they are from a statistical point of view: Just as a quadrat placed at random on the forest floor provides a small sample of it&#39;s species composition, so it is that a sequencing read provides a small sample of the composition of motifs present in a genome. This sample is the universe from which all samples will be drawn.</p><p>Starting with a FASTA formatted file containing the genome that you want to simulate sequencing for, we create such a universe with the <a href="../../api/universe/#Pseudoseq.makeuniverse"><code>makeuniverse</code></a> function as follows:</p><pre><code class="language-julia">universe = makeuniverse(&quot;mygenome.fasta&quot;, 5000)</code></pre><p>Where the second argument is the number of copies of the genome you want to exist in your universe. The example above would create a universe of 5000 copies of the genome in &quot;mygenome.fasta&quot;.</p><div class="admonition tip"><div class="admonition-title">Tip</div><div class="admonition-text"><p>You can think of your universe at this stage as containing many copies of the same genome sequence:</p><pre><code class="language-none">   1. CGGACTTGAATAGCCCAAAGGTTTCGACACGATCACGACACATAAATTGGCGGACTTGAATAGC
   2. CGGACTTGAATAGCCCAAAGGTTTCGACACGATCACGACACATAAATTGGCGGACTTGAATAGC
   3. CGGACTTGAATAGCCCAAAGGTTTCGACACGATCACGACACATAAATTGGCGGACTTGAATAGC
                                ...
4999. CGGACTTGAATAGCCCAAAGGTTTCGACACGATCACGACACATAAATTGGCGGACTTGAATAGC
5000. CGGACTTGAATAGCCCAAAGGTTTCGACACGATCACGACACATAAATTGGCGGACTTGAATAGC</code></pre></div></div><h2><a class="nav-anchor" id="Fragmenting-the-molecules-1" href="#Fragmenting-the-molecules-1">Fragmenting the molecules</a></h2><p>So we have created a perfect universe of 5000 genome molecules.</p><p>If DNA sequencing machines could start at one end of a molecule and sequence all the way to the end with reasonable accuracy and throughput, all we would have to do is select a full DNA molecule from our perfect universe, and run it through a sequencing process to get our genome read. Actually, we&#39;d run several of the molecules from our perfect universe through the sequencer, and use those  reads to form a consensus that eliminates any mistakes a sequencer machine might make - no technology is completely error proof after all and all detection equipment has a certain rate of error.</p><p>Sadly, we don&#39;t have such an amazing sequencer technology that allows the reading of a chromosome in its entirety. Instead, shorter reads are taken of shorter fragments of DNA (even long read technology uses fragments and produces reads, much shorter than the full size of a chromosome molecule).</p><p>A common step in any DNA sequencing experiment, therefore, is to fragment or shear the DNA molecules that are present in the sample.</p><p>Therefore, a common step in any sequencing experiment simulation constructed with <code>Pseudoseq</code> is to fragment the DNA molecules in a universe into smaller ones.</p><p>This is achieved with the <a href="../../api/universe/#Pseudoseq.fragment-Tuple{Pseudoseq.Universe,Int64}"><code>fragment</code></a> method.</p><p><a href="../../api/universe/#Pseudoseq.fragment-Tuple{Pseudoseq.Universe,Int64}"><code>fragment</code></a> is one of the universe transformations briefly mentioned in the introduction. Other transformations include <a href="../../api/universe/#Pseudoseq.subsample-Tuple{Pseudoseq.Universe,Int64}"><code>subsample</code></a> and <code>tag</code>.</p><p>Let&#39;s use it to cut up the molecules in the universe:</p><pre><code class="language-julia">cut_universe = fragment(universe, 700)</code></pre><p>The second value of 700 provided above is the desired expected length of the fragments. The <a href="../../api/universe/#Pseudoseq.fragment-Tuple{Pseudoseq.Universe,Int64}"><code>fragment</code></a> method uses this value, and the length of each molecule it is about to cut, to decide how many breakpoints to scatter across said fragment.</p><div class="admonition tip"><div class="admonition-title">Tip</div><div class="admonition-text"><p>You can visualise this process like so:</p><p>From:</p><pre><code class="language-none">   1. CGGACTTGAATAGCCCAAAGGTTTCGACACGATCACGACACATAAATTGGCGGACTTGAATAGC
   2. CGGACTTGAATAGCCCAAAGGTTTCGACACGATCACGACACATAAATTGGCGGACTTGAATAGC
   3. CGGACTTGAATAGCCCAAAGGTTTCGACACGATCACGACACATAAATTGGCGGACTTGAATAGC
                                ...
4999. CGGACTTGAATAGCCCAAAGGTTTCGACACGATCACGACACATAAATTGGCGGACTTGAATAGC
5000. CGGACTTGAATAGCCCAAAGGTTTCGACACGATCACGACACATAAATTGGCGGACTTGAATAGC</code></pre><p>To:</p><pre><code class="language-none">   1. CGGACTT GAATAGC CCAAA GGTTTCGACACGA TCACGAC ACATAAAT TGGCGGAC TTGAATAGC
   2. CGGA CTTGAAT AGCCCAAAG GTTTCGAC ACGATCACGACACAT AAATTGGCGGA CTTGA ATAGC
   3. CGGACTTGA ATAGCC CAAAGGT TTCGACACGAT CACGACACA TAAATT GGCGGACTT GAATAGC
                                ...
4999. CGGAC TTGAATA GCCCAAAGGTTT CGACACGA TCACGACACAT AAATTG GCGGACTTG AATAGC
5000. CGGACTTGAA TAGCCCA AAGGTTTCGA CACGATCAC GACACA TAAATTGGCGG ACTTGAAT AGC</code></pre></div></div><h2><a class="nav-anchor" id="Subsampling-the-molecules-1" href="#Subsampling-the-molecules-1">Subsampling the molecules</a></h2><p>DNA sequencing experiments are sampling processes, not every one of the  DNA molecules in a sample will be read by the sequencer. So <code>Pseudoseq</code> provides a function to <code>subsample</code> a <code>Universe</code> of DNA fragments.</p><p>This is done with the sample function:</p><pre><code class="language-julia">subsampled_universe = subsample(cut_universe, 463967)</code></pre><p>Where the second numeric argument (463967) is the number of molecules you want to sample.</p><p>Each fragment in the universe is as likely to be sampled as any other. Fragments are sampled without replacement.</p><h3><a class="nav-anchor" id="Determining-the-number-of-fragments-to-sample-1" href="#Determining-the-number-of-fragments-to-sample-1">Determining the number of fragments to sample</a></h3><p>But how did I get to the number 463967?</p><p>Prior to sampling, there is a universe of 33139992 DNA fragments, of on average 700bp in length. There is variation - some fragments are bigger, some are smaller.</p><p>We can estimate how often a base position in the genome is represented in this universe of ~700bp fragments with a simple formula:</p><div>\[C = \frac{LN}{G}\]</div><p>Where <span>$C$</span> is the expected coverage, <span>$L$</span> is the average length of the fragments, and <span>$N$</span> is the number of fragments, and <span>$G$</span> is the number of bases in the genome.</p><p>Given that <span>$L = 700$</span>, <span>$N = 33139992$</span>, and <span>$G = 4639675$</span>:</p><div>\[C = \frac{700 \times 33139992}{4639675} = 5000\]</div><p>Each base in the genome is expected to be represented 5000 times (give or take) in the universe. This makes sense, because if you recall how we created our universe.....</p><pre><code class="language-julia">universe = makeuniverse(&quot;mygenome.fasta&quot;, 5000)</code></pre><p>.....we started with 5000 copies of the genome!</p><p>Ok, so say I wanted to subsample the universe such that each base position in the genome is represented ~50 times. That is, to achieve 50x coverage, you can determine the number of fragments to subsample from the universe, by reversing the formula:</p><div>\[N = \frac{CG}{L}\]</div><p>Filling in the relevant values:</p><div>\[N = \frac{50 \times 4639675}{700} = 331405\]</div><p>So if 331405 700bp fragments were sampled from the universe of 33139992 700bp fragments, you can expect each base in the genome to be represented approximately 50 times.</p><p>But wait! It&#39;s not quite a simple as that! The answer of 331405 would be correct if we were to just pull those fragments out of the universe, and then sequence a complete read of each 700bp fragment in the subsample in its entirety.</p><p>However, that&#39;s not what happens in short read sequencing. Instead, some sub-stretch of the fragment is read by the sequencer, and in the case of paired end sequencing, two sub-stretches of each fragment are read by the sequencer: one from each end of the fragment:</p><pre><code class="language-none">Read 1
-------&gt;
TGAATAGCCCAAAGGTTTCGACA
|||||||||||||||||||||||
ACTTATCGGGTTTCCAAAGCTGT
              &lt;--------
                 Read 2</code></pre><p>Some of the fragment in the middle does not get read by the sequencer.</p><p>So how did I get the answer 463967 above?</p><p>First, I know this simulation is of paired end sequencing, and that the length of each read will be 250bp when we get to that stage of the process. We&#39;re going to sample fragments of 700bp from the universe, and read 250bp in from either end.</p><p>I can estimate how many 700bp fragments I need to sample to achieve 50x coverage with a read length of 250bp, by using the formula with a revised <code>L</code>, setting it to the read length 250bp, instead of the fragment length of 700bp:</p><div>\[N = \frac{50 \times 4639675}{250}\]</div><p>This gives me an <code>N</code> of 927935, which I must divide by 2 (I&#39;m going to be reading two ends of each 700bp DNA fragment I sample), which gives me 463967.</p><div class="admonition tip"><div class="admonition-title">Tip</div><div class="admonition-text"><p>Pseudoseq provides a helper function that assists in this type of calculation:</p><pre><code class="language-julia">genome_size = 4639675
expected_coverage = 50
read_length = 250

N = needed_sample_size(expected_coverage, genome_size, readlength)

# Divide by 2 as we&#39;re doing paired end sequencing i.e 2 reads from one fragment.
div(N, 2)</code></pre></div></div><p>So after all that, we have a subsample of a universe of 700bp fragments. The next step is to produce a set of reads from our universe sample.</p><h2><a class="nav-anchor" id="Creating-the-reads-1" href="#Creating-the-reads-1">Creating the reads</a></h2><p>We now want to create a set of paired-end reads. We want our reads to be 250bp in length.</p><p>We use the <a href="../../api/reads/#Pseudoseq.make_reads"><code>make_reads</code></a> function to achieve this:</p><pre><code class="language-julia">pe_reads = make_reads(PairedEnd, subsampled_universe, 250)</code></pre><p>The first argument to the function is the read type. Possible read types currently provided are <code>PairedEnd</code>, <code>SingleEnd</code>, and <code>TaggedPairs</code>.</p><p>Now we have some reads, we should mark positions in the reads that are destined to be errors in the output FASTQ.</p><p>We do this using the <a href="../../api/reads/#Pseudoseq.mark_errors"><code>mark_errors</code></a> function. The function requires an error rate.</p><pre><code class="language-julia">pe_w_errs = mark_errors(pe_reads, 0.001)</code></pre><h2><a class="nav-anchor" id="Generate-FASTQ-files-1" href="#Generate-FASTQ-files-1">Generate FASTQ files</a></h2><p>Now we have some paired end reads and have marked some positions as errors, we can generate FASTQ files. This is done with the <code>generate</code> function.</p><pre><code class="language-julia">generate(&quot;myreads.fastq&quot;, pe_w_errs)</code></pre><p>.... aaaand thats it! That&#39;s how to simulate paired end sequencing and generate read files using Pseudoseq.</p><footer><hr/><a class="previous" href="../introduction/"><span class="direction">Previous</span><span class="title">Introduction</span></a><a class="next" href="../se_walkthrough/"><span class="direction">Next</span><span class="title">Long single end reads</span></a></footer></article></body></html>
