var documenterSearchIndex = {"docs":
[{"location":"man/sequencing/examples/tg-example/#","page":"Tagged paired end reads","title":"Tagged paired end reads","text":"EditURL = \"https://github.com/bioinfologics/Pseudoseq.jl/blob/master/examples/sequencing/tg-example.jl\"","category":"page"},{"location":"man/sequencing/examples/tg-example/#Example:-tagged-paired-end-reads-1","page":"Tagged paired end reads","title":"Example: tagged paired-end reads","text":"","category":"section"},{"location":"man/sequencing/examples/tg-example/#","page":"Tagged paired end reads","title":"Tagged paired end reads","text":"This is an example generated from this source file: tg-example.jl You are seeing the online documentation version. The corresponding notebook can be found here: tg-example.ipynb and the script can be found here: tg-example.jl","category":"page"},{"location":"man/sequencing/examples/tg-example/#","page":"Tagged paired end reads","title":"Tagged paired end reads","text":"Let's see how we might simulate something like an 10x sequencing experiment.","category":"page"},{"location":"man/sequencing/examples/tg-example/#","page":"Tagged paired end reads","title":"Tagged paired end reads","text":"For this simulation script we will:","category":"page"},{"location":"man/sequencing/examples/tg-example/#","page":"Tagged paired end reads","title":"Tagged paired end reads","text":"Create a pool of 5000 copies of a reference genome.\nFragment the DNA molecules in the pool, to an average length of 40,000bp.\nTag the long molecules in the pool randomly with a set of 1,000,000 tags.\nFragment the molecules in the pool to an average length of 700bp.\nSubsample the molecules in the pool to achieve approximatly 50x coverage.\nCreate a set of 250bp paired-end reads.\nApply errors to the paired-end reads at a rate of 0.001 (.1%).\nGenerate an output FASTQ file.","category":"page"},{"location":"man/sequencing/examples/tg-example/#","page":"Tagged paired end reads","title":"Tagged paired end reads","text":"using Pseudoseq.Sequencing","category":"page"},{"location":"man/sequencing/examples/tg-example/#Using-the-[sequence](@ref)-method-1","page":"Tagged paired end reads","title":"Using the sequence method","text":"","category":"section"},{"location":"man/sequencing/examples/tg-example/#","page":"Tagged paired end reads","title":"Tagged paired end reads","text":"First, let's see how we do this with the sequence method. The first two parameters we give to the function will be the input genome we want to sequence, and the destination FASTQ file for output reads. Here we are setting:","category":"page"},{"location":"man/sequencing/examples/tg-example/#","page":"Tagged paired end reads","title":"Tagged paired end reads","text":"The number of genome copies in the molecule pool to 5,000.\nThe number of possible tags to one million.\nThe average fragment size, prior to tagging, to 40,000bp.\nThe average fragment size after tagging, to 700bp.\nThe sampling coverage to 50x.\nThe read length to 250bp.\nThe per base read error rate to 0.001.\nThe fact we want paired-ends of fragments to be read (paired) to true, which is the default.","category":"page"},{"location":"man/sequencing/examples/tg-example/#","page":"Tagged paired end reads","title":"Tagged paired end reads","text":"sequence(\"ecoli-ref.fasta\", \"tagged_reads.fastq\"; ng = 5000, tusize = 1000000, taggedflen = 40000, flen = 700, cov = 50, rdlen = 250, err = 0.1)","category":"page"},{"location":"man/sequencing/examples/tg-example/#Using-the-Pseudoseq-API-1","page":"Tagged paired end reads","title":"Using the Pseudoseq API","text":"","category":"section"},{"location":"man/sequencing/examples/tg-example/#","page":"Tagged paired end reads","title":"Tagged paired end reads","text":"Here's how to achieve the same thing, using the Pseudoseq API. It is nessecery to use the API if you want to do something that is not anticipated by the available functionality of the sequence method: the cost of conveinience is fewer options.","category":"page"},{"location":"man/sequencing/examples/tg-example/#","page":"Tagged paired end reads","title":"Tagged paired end reads","text":"Let's start with a pool of 5000 copies of a genome contained in a FASTA file:","category":"page"},{"location":"man/sequencing/examples/tg-example/#","page":"Tagged paired end reads","title":"Tagged paired end reads","text":"dnapool = Molecules(\"ecoli-ref.fasta\", 5000)","category":"page"},{"location":"man/sequencing/examples/tg-example/#","page":"Tagged paired end reads","title":"Tagged paired end reads","text":"Now let's cut up the molecules to an average length of 40,000bp","category":"page"},{"location":"man/sequencing/examples/tg-example/#","page":"Tagged paired end reads","title":"Tagged paired end reads","text":"cutpool = fragment(dnapool, 40000)","category":"page"},{"location":"man/sequencing/examples/tg-example/#","page":"Tagged paired end reads","title":"Tagged paired end reads","text":"Ok, now we will tag these large fragments randomly. Once you tag a fragment in a universe, any other fragments that are derived from that tagged fragment will inherit the same tag.","category":"page"},{"location":"man/sequencing/examples/tg-example/#","page":"Tagged paired end reads","title":"Tagged paired end reads","text":"taggedpool = tag(cutpool, 1000000)","category":"page"},{"location":"man/sequencing/examples/tg-example/#","page":"Tagged paired end reads","title":"Tagged paired end reads","text":"Here I'm going to use a pool of 1,000,000 distinct tags. Which fragment gets a certain tag is random. The size of the tag pool, and the number of fragments in your universe will determine how likely it is that any two fragments get the same tag. Now we'll fragment the pool again","category":"page"},{"location":"man/sequencing/examples/tg-example/#","page":"Tagged paired end reads","title":"Tagged paired end reads","text":"taggedcutpool = fragment(taggedpool, 700)","category":"page"},{"location":"man/sequencing/examples/tg-example/#","page":"Tagged paired end reads","title":"Tagged paired end reads","text":"Subsample the pool of tagged molecules.","category":"page"},{"location":"man/sequencing/examples/tg-example/#","page":"Tagged paired end reads","title":"Tagged paired end reads","text":"genome_size = 4639675\nexpected_coverage = 50\nread_length = 250\n\nN = needed_sample_size(expected_coverage, genome_size, read_length)\nN = div(N, 2) # Divide by 2 as we're doing paired end sequencing.\n\nsampledpool = subsample(taggedcutpool, N)","category":"page"},{"location":"man/sequencing/examples/tg-example/#","page":"Tagged paired end reads","title":"Tagged paired end reads","text":"Now let's make some 250bp tagged paired reads and generate some erroneous positions.","category":"page"},{"location":"man/sequencing/examples/tg-example/#","page":"Tagged paired end reads","title":"Tagged paired end reads","text":"tagged_reads = paired_reads(sampledpool, 250)\ntagged_w_errs = mark_errors(tagged_reads, 0.001)","category":"page"},{"location":"man/sequencing/examples/tg-example/#","page":"Tagged paired end reads","title":"Tagged paired end reads","text":"Output to FASTQ:","category":"page"},{"location":"man/sequencing/examples/tg-example/#","page":"Tagged paired end reads","title":"Tagged paired end reads","text":"generate(\"tagged_reads.fastq\", tagged_w_errs)","category":"page"},{"location":"man/sequencing/examples/tg-example/#","page":"Tagged paired end reads","title":"Tagged paired end reads","text":"","category":"page"},{"location":"man/sequencing/examples/tg-example/#","page":"Tagged paired end reads","title":"Tagged paired end reads","text":"This page was generated using Literate.jl.","category":"page"},{"location":"man/sequencing/examples/pe-example/#","page":"Paired end reads","title":"Paired end reads","text":"EditURL = \"https://github.com/bioinfologics/Pseudoseq.jl/blob/master/examples/sequencing/pe-example.jl\"","category":"page"},{"location":"man/sequencing/examples/pe-example/#Example:-paired-end-sequencing-1","page":"Paired end reads","title":"Example: paired-end sequencing","text":"","category":"section"},{"location":"man/sequencing/examples/pe-example/#","page":"Paired end reads","title":"Paired end reads","text":"This is an example generated from this source file: pe-example.jl You are seeing the online documentation version. The corresponding notebook can be found here: pe-example.ipynb and the script can be found here: pe-example.jl","category":"page"},{"location":"man/sequencing/examples/pe-example/#","page":"Paired end reads","title":"Paired end reads","text":"For the simulation we are going to:","category":"page"},{"location":"man/sequencing/examples/pe-example/#","page":"Paired end reads","title":"Paired end reads","text":"Create a pool of 5000 copies of a reference genome.\nFragment the DNA molecules in the pool, to an average length of 700bp.\nSubsample the molecules in the pool to achieve approximatly 50x coverage.\nCreate a set of 250bp paired-end reads.\nApply errors to the paired-end reads at a rate of 0.001 (.1%).\nGenerate an output FASTQ file.","category":"page"},{"location":"man/sequencing/examples/pe-example/#","page":"Paired end reads","title":"Paired end reads","text":"using Pseudoseq.Sequencing","category":"page"},{"location":"man/sequencing/examples/pe-example/#Using-the-[sequence](@ref)-method-1","page":"Paired end reads","title":"Using the sequence method","text":"","category":"section"},{"location":"man/sequencing/examples/pe-example/#","page":"Paired end reads","title":"Paired end reads","text":"First, let's see how we do this with the sequence method. The first two parameters we give to the function will be the input genome we want to sequence, and the destination FASTQ file for output reads. Here we are setting:","category":"page"},{"location":"man/sequencing/examples/pe-example/#","page":"Paired end reads","title":"Paired end reads","text":"The number of genome copies in the molecule pool to 5000.\nThe average fragment size to 700bp.\nThe sampling coverage to 50x.\nThe read length to 250bp.\nThe per base read error rate to 0.001.\nThe fact we want paired-ends of fragments to be read (paired) to true.","category":"page"},{"location":"man/sequencing/examples/pe-example/#","page":"Paired end reads","title":"Paired end reads","text":"sequence(\"ecoli-ref.fasta\", \"pe-reads.fastq\"; ng = 5000, flen = 700, cov = 50, paired = true, rdlen = 250, err = 0.001)","category":"page"},{"location":"man/sequencing/examples/pe-example/#Using-the-Molecules-tranformation-methods.-1","page":"Paired end reads","title":"Using the Molecules tranformation methods.","text":"","category":"section"},{"location":"man/sequencing/examples/pe-example/#","page":"Paired end reads","title":"Paired end reads","text":"Here's how to achieve the same thing, using the Pseudoseq API. It is nessecery to use the API if you want to do something that is not anticipated by the available functionality of the sequence method: the cost of conveinience is fewer options.","category":"page"},{"location":"man/sequencing/examples/pe-example/#","page":"Paired end reads","title":"Paired end reads","text":"Starting with a FASTA formatted file containing the genome we want to sequence, we create a pool with 5000 copies of the genome.","category":"page"},{"location":"man/sequencing/examples/pe-example/#","page":"Paired end reads","title":"Paired end reads","text":"pool = Molecules(\"ecoli-ref.fasta\", 5000)","category":"page"},{"location":"man/sequencing/examples/pe-example/#","page":"Paired end reads","title":"Paired end reads","text":"Next we use the fragment function to make a pool of shorter DNA molecules.","category":"page"},{"location":"man/sequencing/examples/pe-example/#","page":"Paired end reads","title":"Paired end reads","text":"cutpool = fragment(pool, 700)","category":"page"},{"location":"man/sequencing/examples/pe-example/#","page":"Paired end reads","title":"Paired end reads","text":"We need to determine the number of molecules to sample, and subsample the pool:","category":"page"},{"location":"man/sequencing/examples/pe-example/#","page":"Paired end reads","title":"Paired end reads","text":"genome_size = 4639675\nexpected_coverage = 50\nread_length = 250\n\nN = needed_sample_size(expected_coverage, genome_size, read_length)\nN = div(N, 2) # Divide by 2 as we're doing paired end sequencing.\n\nsampledpool = subsample(cutpool, N)","category":"page"},{"location":"man/sequencing/examples/pe-example/#","page":"Paired end reads","title":"Paired end reads","text":"We now want to create a set of paired-end reads. We want our reads to be 250bp in length.","category":"page"},{"location":"man/sequencing/examples/pe-example/#","page":"Paired end reads","title":"Paired end reads","text":"pe_reads = paired_reads(sampledpool, 250)","category":"page"},{"location":"man/sequencing/examples/pe-example/#","page":"Paired end reads","title":"Paired end reads","text":"Now we have some reads, we should mark positions in the reads that are destined to be errors in the output FASTQ.","category":"page"},{"location":"man/sequencing/examples/pe-example/#","page":"Paired end reads","title":"Paired end reads","text":"pe_w_errs = mark_errors(pe_reads, 0.001)","category":"page"},{"location":"man/sequencing/examples/pe-example/#","page":"Paired end reads","title":"Paired end reads","text":"Now we have some paired end reads and have marked some positions as errors, we can generate FASTQ files.","category":"page"},{"location":"man/sequencing/examples/pe-example/#","page":"Paired end reads","title":"Paired end reads","text":"generate(\"pe-reads.fastq\", pe_w_errs)","category":"page"},{"location":"man/sequencing/examples/pe-example/#Constructing-a-pipeline-of-Processors.-1","page":"Paired end reads","title":"Constructing a pipeline of Processors.","text":"","category":"section"},{"location":"man/sequencing/examples/pe-example/#","page":"Paired end reads","title":"Paired end reads","text":"As a convenience, some users may prefer to use pipelines of Processors These behave like curried versions of the Molecules transformation methods. First let's define our starting Molecules pool:","category":"page"},{"location":"man/sequencing/examples/pe-example/#","page":"Paired end reads","title":"Paired end reads","text":"pool = Molecules(\"ecoli-ref.fasta\", 5000)","category":"page"},{"location":"man/sequencing/examples/pe-example/#","page":"Paired end reads","title":"Paired end reads","text":"To make a Processor, use a Molecules transformation method, but do not provide a Molecules value as a first argument. So let's make Processors for each step of our paired end sequencing pipeline.","category":"page"},{"location":"man/sequencing/examples/pe-example/#","page":"Paired end reads","title":"Paired end reads","text":"cutter = fragment(700)\nsampler = subsample(N) # Remember how to computed N previously.\nmkreads = paired_reads(250)\nadderr = mark_errors(0.001)","category":"page"},{"location":"man/sequencing/examples/pe-example/#","page":"Paired end reads","title":"Paired end reads","text":"Next we can construct the pipeline using standard julia function pipelining syntax:","category":"page"},{"location":"man/sequencing/examples/pe-example/#","page":"Paired end reads","title":"Paired end reads","text":"pool |> cutter |> sampler |> mkreads |> adderr |> generate(\"pe-reads.fastq\")","category":"page"},{"location":"man/sequencing/examples/pe-example/#","page":"Paired end reads","title":"Paired end reads","text":"You can also compose the processors together into one whole function. Typing \\circ in the julia repl and then hitting tab gives you the circular composition symbol. Note how pipelining above progresses from left to right, but composition is right to left in order.","category":"page"},{"location":"man/sequencing/examples/pe-example/#","page":"Paired end reads","title":"Paired end reads","text":"my_protocol = adderr ∘ mkreads ∘ sampler ∘ cutter\n\npool |> my_protocol |> generate(\"pe-reads.fastq\")","category":"page"},{"location":"man/sequencing/examples/pe-example/#","page":"Paired end reads","title":"Paired end reads","text":"","category":"page"},{"location":"man/sequencing/examples/pe-example/#","page":"Paired end reads","title":"Paired end reads","text":"This page was generated using Literate.jl.","category":"page"},{"location":"api/pool/#API:-MoleculePool-1","page":"Molecule Pool","title":"API: MoleculePool","text":"","category":"section"},{"location":"api/pool/#Exported-functions-1","page":"Molecule Pool","title":"Exported functions","text":"","category":"section"},{"location":"api/pool/#Making-a-pool-of-molecules-1","page":"Molecule Pool","title":"Making a pool of molecules","text":"","category":"section"},{"location":"api/pool/#","page":"Molecule Pool","title":"Molecule Pool","text":"Molecules","category":"page"},{"location":"api/pool/#Molecule-pool-transformations-1","page":"Molecule Pool","title":"Molecule pool transformations","text":"","category":"section"},{"location":"api/pool/#Fragment-1","page":"Molecule Pool","title":"Fragment","text":"","category":"section"},{"location":"api/pool/#","page":"Molecule Pool","title":"Molecule Pool","text":"fragment(p::Pseudoseq.MoleculePool, meansize::Int)","category":"page"},{"location":"api/pool/#Subsampling-1","page":"Molecule Pool","title":"Subsampling","text":"","category":"section"},{"location":"api/pool/#","page":"Molecule Pool","title":"Molecule Pool","text":"subsample(p::Pseudoseq.MoleculePool, n::Int)","category":"page"},{"location":"api/pool/#Tagging-1","page":"Molecule Pool","title":"Tagging","text":"","category":"section"},{"location":"api/pool/#","page":"Molecule Pool","title":"Molecule Pool","text":"tag(p::Pseudoseq.MoleculePool, ntags::Int)","category":"page"},{"location":"api/pool/#Flipping-1","page":"Molecule Pool","title":"Flipping","text":"","category":"section"},{"location":"api/pool/#","page":"Molecule Pool","title":"Molecule Pool","text":"flip(p::Pseudoseq.MoleculePool)","category":"page"},{"location":"api/sequence/#API:-sequence-1","page":"sequence","title":"API: sequence","text":"","category":"section"},{"location":"api/sequence/#Exported-functions-1","page":"sequence","title":"Exported functions","text":"","category":"section"},{"location":"api/sequence/#","page":"sequence","title":"sequence","text":"sequence","category":"page"},{"location":"man/puzzlemaker/concepts/#PuzzleMaker:-*Core-concepts-and-basic-workflow*-1","page":"PuzzleMaker","title":"PuzzleMaker: Core concepts & basic workflow","text":"","category":"section"},{"location":"man/puzzlemaker/concepts/#","page":"PuzzleMaker","title":"PuzzleMaker","text":"Pseudoseq allows you to create puzzles; planned genomes and chromosome that have a certain set of features and peculiarities of interest.","category":"page"},{"location":"man/puzzlemaker/concepts/#","page":"PuzzleMaker","title":"PuzzleMaker","text":"The purpose for creating such puzzle genomes is not to recreate biology perfectly. The purpose is to create problems you understand fully (where the repeated content is, which positions are heterozygous and so on).","category":"page"},{"location":"man/puzzlemaker/concepts/#","page":"PuzzleMaker","title":"PuzzleMaker","text":"Using such genomes can help you both understand and develop an intuition of what current genome assembly tools are doing, and also to help design assembly tools, and perhaps even plan sequencing experiments and form hypotheses.","category":"page"},{"location":"man/puzzlemaker/concepts/#","page":"PuzzleMaker","title":"PuzzleMaker","text":"PuzzleMaker is the Pseudoseq submodule that contains the functionality for doing this. This manual includes several examples showing how to create genomes with certain characteristics. But the core workflow, and important concepts are explained below.","category":"page"},{"location":"man/puzzlemaker/concepts/#The-MotifStitcher-1","page":"PuzzleMaker","title":"The MotifStitcher","text":"","category":"section"},{"location":"man/puzzlemaker/concepts/#","page":"PuzzleMaker","title":"PuzzleMaker","text":"The MotifStitcher is the type that is central to PuzzleMaker. It is by creating and interacting with a MotifStitcher, you create the plan for your puzzle in 3 simple steps. First you define motifs, then you decide on the order of motifs, and then you generate one or more instances of the puzzle by calling make_puzzle on your MotifStitcher.","category":"page"},{"location":"man/puzzlemaker/concepts/#","page":"PuzzleMaker","title":"PuzzleMaker","text":"Let's take a look at step 1.","category":"page"},{"location":"man/puzzlemaker/concepts/#.-Define-Motifs-1","page":"PuzzleMaker","title":"1. Define Motifs","text":"","category":"section"},{"location":"man/puzzlemaker/concepts/#","page":"PuzzleMaker","title":"PuzzleMaker","text":"The MotifSticher allows you to programmatically create puzzle haplotype sequences by first defining a set of motifs, motifs are shorter chunks of user specified or randomly generated sequence, that will be \"stitched\" together to form the final haplotype sequences.","category":"page"},{"location":"man/puzzlemaker/concepts/#","page":"PuzzleMaker","title":"PuzzleMaker","text":"There are three kinds of motif that can be added to the MotifStitcher.","category":"page"},{"location":"man/puzzlemaker/concepts/#","page":"PuzzleMaker","title":"PuzzleMaker","text":"A random motif.\nA fixed motif.\nA sibling motif.","category":"page"},{"location":"man/puzzlemaker/concepts/#Random-motifs-1","page":"PuzzleMaker","title":"Random motifs","text":"","category":"section"},{"location":"man/puzzlemaker/concepts/#","page":"PuzzleMaker","title":"PuzzleMaker","text":"A random motif is a motif that will change between calls to make_puzzle. The reason is so as you can trivially make multiple replicate puzzles with the same properties, but with different specific sequences.","category":"page"},{"location":"man/puzzlemaker/concepts/#","page":"PuzzleMaker","title":"PuzzleMaker","text":"You can add a random motif to a MotifStitcher by using the add_motif! method, and specifying only a length (in bp) for the random motif, for example:","category":"page"},{"location":"man/puzzlemaker/concepts/#","page":"PuzzleMaker","title":"PuzzleMaker","text":"using Pseudoseq.PuzzleMaker\nusing BioSequences","category":"page"},{"location":"man/puzzlemaker/concepts/#","page":"PuzzleMaker","title":"PuzzleMaker","text":"ms = MotifStitcher()\nadd_motif!(ms, 10_000)","category":"page"},{"location":"man/puzzlemaker/concepts/#","page":"PuzzleMaker","title":"PuzzleMaker","text":"By default, a random motif is constructed using a sampler that gives equal weighting to the four nucleotides. If you wanted more control over some of the nucleotide biases. You can construct a RandomMotif yourself, and provide it with your own nucleotide sampler:","category":"page"},{"location":"man/puzzlemaker/concepts/#","page":"PuzzleMaker","title":"PuzzleMaker","text":"ms = MotifStitcher()\nsmp = SamplerWeighted(dna\"ACGT\", [0.2, 0.3, 0.3,]) # Sampler biased toward GC.\nadd_motif!(ms, RandomMotif(10_000, smp)) # RandomMotif of 10_000 bp in length, using custom sampler.","category":"page"},{"location":"man/puzzlemaker/concepts/#","page":"PuzzleMaker","title":"PuzzleMaker","text":"note: Note\nOnly SamplerWeighted{DNA} types are accepted.","category":"page"},{"location":"man/puzzlemaker/concepts/#Fixed-motifs-1","page":"PuzzleMaker","title":"Fixed motifs","text":"","category":"section"},{"location":"man/puzzlemaker/concepts/#","page":"PuzzleMaker","title":"PuzzleMaker","text":"Unlike a random motif, a fixed motif has its sequence defined and constant over multiple calls of make_puzzle.","category":"page"},{"location":"man/puzzlemaker/concepts/#","page":"PuzzleMaker","title":"PuzzleMaker","text":"This is useful for situations where your puzzles must always include a certain DNA sequence. Perhaps one of biological interest or known to confuse a heuristic.","category":"page"},{"location":"man/puzzlemaker/concepts/#","page":"PuzzleMaker","title":"PuzzleMaker","text":"You add a fixed motif to a MotifStitcher simply by passing it a DNA sequence:","category":"page"},{"location":"man/puzzlemaker/concepts/#","page":"PuzzleMaker","title":"PuzzleMaker","text":"ms = MotifStitcher()\nadd_motif!(ms, dna\"ATCGATCG\")","category":"page"},{"location":"man/puzzlemaker/concepts/#Sibling-motifs-1","page":"PuzzleMaker","title":"Sibling motifs","text":"","category":"section"},{"location":"man/puzzlemaker/concepts/#","page":"PuzzleMaker","title":"PuzzleMaker","text":"A sibling motif is a motif that is randomly generated for each call of make_puzzle just like random motifs. However, unlike random motifs, a sibling motif is defined in terms of another motif already defined in the MotifStitcher.","category":"page"},{"location":"man/puzzlemaker/concepts/#","page":"PuzzleMaker","title":"PuzzleMaker","text":"To define a sibling motif, you specify an already existing motif. That motif's sequence forms the base sequence of the new sibling motif. To define a sibling motif you also need to provide a value that specifies the proportion of bases in the new sibling motif's sequence, that should differ in their nucleic acid from the base motifs sequence.","category":"page"},{"location":"man/puzzlemaker/concepts/#","page":"PuzzleMaker","title":"PuzzleMaker","text":"So sibling motifs then make it simple to define motifs that have a certain level of sequence similarity / homology / shared ancestry, with another motif. Creating portions of a simulated diploid genome might be one practical application of sibling motifs.","category":"page"},{"location":"man/puzzlemaker/concepts/#","page":"PuzzleMaker","title":"PuzzleMaker","text":"You add a sibling motif to the MotifStitcher by providing the add_motif! method with an Pair{Int,Float64}. where the integer is the ID of the chosen base motif already defined in the MotifStitcher, and the floating point number specifies the proportion of differing bases in the new motif's sequence:","category":"page"},{"location":"man/puzzlemaker/concepts/#","page":"PuzzleMaker","title":"PuzzleMaker","text":"ms = MotifStitcher()\nadd_motif!(ms, 10_000) # A random first 10,000bp motif. Has ID = 1.\nadd_motif!(ms, 1 => 0.01) # Add a sibling motif that will have ~10 bases which differ from motif #1. Will have ID = 2.","category":"page"},{"location":"man/puzzlemaker/concepts/#.-Specify-haplotypes-1","page":"PuzzleMaker","title":"2. Specify haplotypes","text":"","category":"section"},{"location":"man/puzzlemaker/concepts/#","page":"PuzzleMaker","title":"PuzzleMaker","text":"Once you have a set of motifs defined, you can build a set of haplotypes by specifying sequences of motifs.","category":"page"},{"location":"man/puzzlemaker/concepts/#","page":"PuzzleMaker","title":"PuzzleMaker","text":"note: Note\nYou specify the motifs using a vector of ID numbers. If you use a negative ID number -N then it means the reverse complement of the sequence of motif N.","category":"page"},{"location":"man/puzzlemaker/concepts/#","page":"PuzzleMaker","title":"PuzzleMaker","text":"note: Note\nA motif's ID can be repeated in such a vector any number of times, so you can create repeat structures in a haplotype. ","category":"page"},{"location":"man/puzzlemaker/concepts/#","page":"PuzzleMaker","title":"PuzzleMaker","text":"You add a haplotype by using the add_motif_arrangement! method with a MotifStitcher and a vector of motif IDs.","category":"page"},{"location":"man/puzzlemaker/concepts/#","page":"PuzzleMaker","title":"PuzzleMaker","text":"For example, let's make a sequence that would form a hair-pin like structure, with repeats when turned into a DeBruijn graph.","category":"page"},{"location":"man/puzzlemaker/concepts/#","page":"PuzzleMaker","title":"PuzzleMaker","text":"ms = MotifStitcher()\nadd_motifs!(ms, 10000, 600, 10000, 600, 10000, 10000, 10000) # Use add_motifs! to add multiple random motifs at once.\nadd_motif_arrangement!(ms, [1, 2, 3, 4, 5, -4, -6, -2, 7])","category":"page"},{"location":"man/puzzlemaker/concepts/#.-Generate-haplotype-sequences-1","page":"PuzzleMaker","title":"3. Generate haplotype sequences","text":"","category":"section"},{"location":"man/puzzlemaker/concepts/#","page":"PuzzleMaker","title":"PuzzleMaker","text":"With the motifs defined and the haplotypes defined you can now generate sequences!","category":"page"},{"location":"man/puzzlemaker/concepts/#","page":"PuzzleMaker","title":"PuzzleMaker","text":"Simply call the make_puzzle method on the MotifStitcher to get a vector of haplotype sequences. Repeatedly call make_puzzle to get independently generated sequences from the same specification:","category":"page"},{"location":"man/puzzlemaker/concepts/#","page":"PuzzleMaker","title":"PuzzleMaker","text":"make_puzzle(ms)\nmake_puzzle(ms)","category":"page"},{"location":"man/puzzlemaker/concepts/#","page":"PuzzleMaker","title":"PuzzleMaker","text":"If you provide a filename, the haplotypes will be written to file in FASTA format, instead of returned as a value:","category":"page"},{"location":"man/puzzlemaker/concepts/#","page":"PuzzleMaker","title":"PuzzleMaker","text":"make_puzzle(ms, \"myhaplos.fasta\")","category":"page"},{"location":"man/puzzlemaker/concepts/#","page":"PuzzleMaker","title":"PuzzleMaker","text":"That's all there is to it. Now you can try a simulated sequencing experiment on your haplotypes. ","category":"page"},{"location":"man/sequencing/examples/se-example/#","page":"Long single end reads","title":"Long single end reads","text":"EditURL = \"https://github.com/bioinfologics/Pseudoseq.jl/blob/master/examples/sequencing/se-example.jl\"","category":"page"},{"location":"man/sequencing/examples/se-example/#Example:-long,-single-end-reads-1","page":"Long single end reads","title":"Example: long, single end reads","text":"","category":"section"},{"location":"man/sequencing/examples/se-example/#","page":"Long single end reads","title":"Long single end reads","text":"This is an example generated from this source file: se-example.jl You are seeing the online documentation version. The corresponding notebook can be found here: se-example.ipynb and the script can be found here: se-example.jl","category":"page"},{"location":"man/sequencing/examples/se-example/#","page":"Long single end reads","title":"Long single end reads","text":"Let's see how you might simulate something like an Oxford Nanopore sequencing experiment.","category":"page"},{"location":"man/sequencing/examples/se-example/#","page":"Long single end reads","title":"Long single end reads","text":"For the simulation we are going to:","category":"page"},{"location":"man/sequencing/examples/se-example/#","page":"Long single end reads","title":"Long single end reads","text":"Create a pool of 5000 copies of a reference genome.\nFragment the DNA molecules in the pool, to an average length of 40,000bp.\nSubsample the molecules in the pool to achieve approximatly 30x coverage.\nCreate a set of single-end reads, the enitre length of each molecule.\nApply errors to the reads at a rate of 0.10 (1 error every 10bp).\nGenerate an output FASTQ file.","category":"page"},{"location":"man/sequencing/examples/se-example/#","page":"Long single end reads","title":"Long single end reads","text":"using Pseudoseq.Sequencing","category":"page"},{"location":"man/sequencing/examples/se-example/#Using-the-[sequence](@ref)-method-1","page":"Long single end reads","title":"Using the sequence method","text":"","category":"section"},{"location":"man/sequencing/examples/se-example/#","page":"Long single end reads","title":"Long single end reads","text":"First, let's see how we do this with the sequence method. The first two parameters we give to the function will be the input genome we want to sequence, and the destination FASTQ file for output reads. Here we are setting:","category":"page"},{"location":"man/sequencing/examples/se-example/#","page":"Long single end reads","title":"Long single end reads","text":"The number of genome copies in the molecule pool to 5000.\nThe average fragment size to 40000bp.\nThe sampling coverage to 30x.\nThe read length to nothing, which will make the sequencer read the whole length of any DNA fragment.\nThe per base read error rate to 0.1.\nThe fact we want paired-ends of fragments to be read (paired) to false.","category":"page"},{"location":"man/sequencing/examples/se-example/#","page":"Long single end reads","title":"Long single end reads","text":"sequence(\"ecoli-ref.fasta\", \"longreads.fastq\"; ng = 5000, flen = 40000, cov = 30, rdlen = nothing, err = 0.1, paired = false)","category":"page"},{"location":"man/sequencing/examples/se-example/#Using-the-Pseudoseq-API-1","page":"Long single end reads","title":"Using the Pseudoseq API","text":"","category":"section"},{"location":"man/sequencing/examples/se-example/#","page":"Long single end reads","title":"Long single end reads","text":"Here's how to achieve the same thing, using the Pseudoseq API. It is nessecery to use the API if you want to do something that is not anticipated by the available functionality of the sequence method: the cost of conveinience is fewer options.","category":"page"},{"location":"man/sequencing/examples/se-example/#","page":"Long single end reads","title":"Long single end reads","text":"Let's start with a pool of 5000 copies of a genome contained in a FASTA file:","category":"page"},{"location":"man/sequencing/examples/se-example/#","page":"Long single end reads","title":"Long single end reads","text":"pool = Molecules(\"ecoli-ref.fasta\", 5000)","category":"page"},{"location":"man/sequencing/examples/se-example/#","page":"Long single end reads","title":"Long single end reads","text":"Cut the pool of DNA into fragments of an average length of 40,000bp","category":"page"},{"location":"man/sequencing/examples/se-example/#","page":"Long single end reads","title":"Long single end reads","text":"cutpool = fragment(pool, 40000)","category":"page"},{"location":"man/sequencing/examples/se-example/#","page":"Long single end reads","title":"Long single end reads","text":"Now we'll estimate the number of fragments we need to sample from the pool to achieve 30x coverage.","category":"page"},{"location":"man/sequencing/examples/se-example/#","page":"Long single end reads","title":"Long single end reads","text":"genome_size = 4639675\nexpected_coverage = 30\nreadlength = 40000\n\nN = needed_sample_size(expected_coverage, genome_size, readlength)\n\nsampledpool = subsample(cutpool, N)","category":"page"},{"location":"man/sequencing/examples/se-example/#","page":"Long single end reads","title":"Long single end reads","text":"By using the make_reads function without specifying a read length, the function will generate reads from the entire length of each molecule in the pool. We do this to emulate what Nanopore sequencing is supposed to do: It takes an entire DNA fragment, feeds it through an electrically charged pore, producing a read for the entire fragment.","category":"page"},{"location":"man/sequencing/examples/se-example/#","page":"Long single end reads","title":"Long single end reads","text":"se_reads = unpaired_reads(sampledpool, nothing)","category":"page"},{"location":"man/sequencing/examples/se-example/#","page":"Long single end reads","title":"Long single end reads","text":"Long read sequencer have much higher error rates than short read sequencers so we use a error rate of 0.1.","category":"page"},{"location":"man/sequencing/examples/se-example/#","page":"Long single end reads","title":"Long single end reads","text":"se_w_errs = mark_errors(se_reads, 0.1)","category":"page"},{"location":"man/sequencing/examples/se-example/#","page":"Long single end reads","title":"Long single end reads","text":"Finally produce the ouput FASTQ file.","category":"page"},{"location":"man/sequencing/examples/se-example/#","page":"Long single end reads","title":"Long single end reads","text":"generate(\"longreads.fastq\", se_w_errs)","category":"page"},{"location":"man/sequencing/examples/se-example/#Constructing-a-pipeline-of-Processors.-1","page":"Long single end reads","title":"Constructing a pipeline of Processors.","text":"","category":"section"},{"location":"man/sequencing/examples/se-example/#","page":"Long single end reads","title":"Long single end reads","text":"As a convenience, some users may prefer to use pipelines of Processors These behave like curried versions of the Molecules transformation methods. First let's define our starting Molecules pool:","category":"page"},{"location":"man/sequencing/examples/se-example/#","page":"Long single end reads","title":"Long single end reads","text":"pool = Molecules(\"ecoli-ref.fasta\", 5000)","category":"page"},{"location":"man/sequencing/examples/se-example/#","page":"Long single end reads","title":"Long single end reads","text":"To make a Processor, use a Molecules transformation method, but do not provide a Molecules value as a first argument. So let's make Processors for each step of our single end sequencing pipeline.","category":"page"},{"location":"man/sequencing/examples/se-example/#","page":"Long single end reads","title":"Long single end reads","text":"cutter = fragment(40000)\nsampler = subsample(N) # Remember how to computed N previously.\nmkreads = unpaired_reads(nothing)\nadderr = mark_errors(0.1)","category":"page"},{"location":"man/sequencing/examples/se-example/#","page":"Long single end reads","title":"Long single end reads","text":"Next we can construct the pipeline using standard julia function pipelining syntax:","category":"page"},{"location":"man/sequencing/examples/se-example/#","page":"Long single end reads","title":"Long single end reads","text":"pool |> cutter |> sampler |> mkreads |> adderr |> generate(\"se-reads.fastq\")","category":"page"},{"location":"man/sequencing/examples/se-example/#","page":"Long single end reads","title":"Long single end reads","text":"You can also compose the processors together into one whole function. Typing \\circ in the julia repl and then hitting tab gives you the circular composition symbol. Note how pipelining above progresses from left to right, but composition is right to left in order.","category":"page"},{"location":"man/sequencing/examples/se-example/#","page":"Long single end reads","title":"Long single end reads","text":"my_protocol = adderr ∘ mkreads ∘ sampler ∘ cutter\n\npool |> my_protocol |> generate(\"se-reads.fastq\")","category":"page"},{"location":"man/sequencing/examples/se-example/#","page":"Long single end reads","title":"Long single end reads","text":"","category":"page"},{"location":"man/sequencing/examples/se-example/#","page":"Long single end reads","title":"Long single end reads","text":"This page was generated using Literate.jl.","category":"page"},{"location":"man/sequencing/concepts/#Sequencing:-*Core-concepts-and-basic-workflow*-1","page":"Core concepts & workflow","title":"Sequencing: Core concepts & basic workflow","text":"","category":"section"},{"location":"man/sequencing/concepts/#","page":"Core concepts & workflow","title":"Core concepts & workflow","text":"Pseudoseq abstracts DNA sequencing experiments as sampling processes, because this is what they are from a statistical point of view. Just as a quadrat placed at random on the forest floor provides a small sample of it's species composition, so it is that a sequencing read provides a small sample of the composition of the motifs present in a genome.","category":"page"},{"location":"man/sequencing/concepts/#","page":"Core concepts & workflow","title":"Core concepts & workflow","text":"This manual includes several examples showing how to emulate various sequencing experiments using different technologies. But the core workflow, and important concepts are outlined below.","category":"page"},{"location":"man/sequencing/concepts/#","page":"Core concepts & workflow","title":"Core concepts & workflow","text":"tip: Tip\nThe user can use Pseudoseq's API to script each stage of the flow outlined below themselves, or they can use the sequence function, which is the highest-level user facing function. Every example in this section of the manual, will show you how to use both options to achieve the same goal.","category":"page"},{"location":"man/sequencing/concepts/#","page":"Core concepts & workflow","title":"Core concepts & workflow","text":"Anyway, the core sequencing workflow in Pseudoseq is as follows...","category":"page"},{"location":"man/sequencing/concepts/#.-Create-a-pool-of-DNA-molecules-1","page":"Core concepts & workflow","title":"1. Create a pool of DNA molecules","text":"","category":"section"},{"location":"man/sequencing/concepts/#","page":"Core concepts & workflow","title":"Core concepts & workflow","text":"In reality, all DNA sequencing experiments begin with a sample of tissue or cells. DNA is extracted from the sample in the laboratory, after the genomes of the cells exist as number of DNA molecules, suspended in a solution.","category":"page"},{"location":"man/sequencing/concepts/#","page":"Core concepts & workflow","title":"Core concepts & workflow","text":"In Pseudoseq, such a collection of DNA molecules is called a molecule pool, it is created with the Molecules constructor function.","category":"page"},{"location":"man/sequencing/concepts/#","page":"Core concepts & workflow","title":"Core concepts & workflow","text":"In the beginning of a Psueodseq simulation script you create a pool that is the totality of all copies of the genome that exist in your simulation.","category":"page"},{"location":"man/sequencing/concepts/#","page":"Core concepts & workflow","title":"Core concepts & workflow","text":"tip: Tip\nYou can think of the pool at this stage as containing many copies of the same genome sequence:   1. CGGACTTGAATAGCCCAAAGGTTTCGACACGATCACGACACATAAATTGGCGGACTTGAATAGC\n   2. CGGACTTGAATAGCCCAAAGGTTTCGACACGATCACGACACATAAATTGGCGGACTTGAATAGC\n   3. CGGACTTGAATAGCCCAAAGGTTTCGACACGATCACGACACATAAATTGGCGGACTTGAATAGC\n                                ...\n4999. CGGACTTGAATAGCCCAAAGGTTTCGACACGATCACGACACATAAATTGGCGGACTTGAATAGC\n5000. CGGACTTGAATAGCCCAAAGGTTTCGACACGATCACGACACATAAATTGGCGGACTTGAATAGC","category":"page"},{"location":"man/sequencing/concepts/#.-Process-the-DNA-molecule-pool-1","page":"Core concepts & workflow","title":"2. Process the DNA molecule pool","text":"","category":"section"},{"location":"man/sequencing/concepts/#","page":"Core concepts & workflow","title":"Core concepts & workflow","text":"You then subject your starting DNA molecule pool to a series of transformations, until the pool has the properties you want to emulate.","category":"page"},{"location":"man/sequencing/concepts/#","page":"Core concepts & workflow","title":"Core concepts & workflow","text":"Here we will describe the different transformations you can apply to a DNA molecule pool:","category":"page"},{"location":"man/sequencing/concepts/#Fragmenting-the-pool-1","page":"Core concepts & workflow","title":"Fragmenting the pool","text":"","category":"section"},{"location":"man/sequencing/concepts/#","page":"Core concepts & workflow","title":"Core concepts & workflow","text":"In an ideal world, if DNA sequencing machines could start at one end of a molecule and read the sequence all the way to the end with reasonable accuracy and throughput, you could simulate that by selecting molecules from your pool, and producing a read file. Give or take some inevitable errors (all detection equipment has a rate of error), assembling a genome would be simple.","category":"page"},{"location":"man/sequencing/concepts/#","page":"Core concepts & workflow","title":"Core concepts & workflow","text":"Sadly, we don't have such an amazing sequencer technology that allows the reading of a chromosome in its entirety. Instead, shorter reads are taken of short fragments of DNA. Even long read technology uses fragments and produces reads, much shorter than the full size of a chromosome molecule.","category":"page"},{"location":"man/sequencing/concepts/#","page":"Core concepts & workflow","title":"Core concepts & workflow","text":"A common step in any DNA sequencing experiment, therefore, is to fragment or shear the DNA molecules that are present in the pool.","category":"page"},{"location":"man/sequencing/concepts/#","page":"Core concepts & workflow","title":"Core concepts & workflow","text":"This is achieved in Pseudoseq with the fragment function.","category":"page"},{"location":"man/sequencing/concepts/#","page":"Core concepts & workflow","title":"Core concepts & workflow","text":"tip: Tip\nYou can visualise this process like so:From:   1. CGGACTTGAATAGCCCAAAGGTTTCGACACGATCACGACACATAAATTGGCGGACTTGAATAGC\n   2. CGGACTTGAATAGCCCAAAGGTTTCGACACGATCACGACACATAAATTGGCGGACTTGAATAGC\n   3. CGGACTTGAATAGCCCAAAGGTTTCGACACGATCACGACACATAAATTGGCGGACTTGAATAGC\n                                ...\n4999. CGGACTTGAATAGCCCAAAGGTTTCGACACGATCACGACACATAAATTGGCGGACTTGAATAGC\n5000. CGGACTTGAATAGCCCAAAGGTTTCGACACGATCACGACACATAAATTGGCGGACTTGAATAGCTo:   1. CGGACTT GAATAGC CCAAA GGTTTCGACACGA TCACGAC ACATAAAT TGGCGGAC TTGAATAGC\n   2. CGGA CTTGAAT AGCCCAAAG GTTTCGAC ACGATCACGACACAT AAATTGGCGGA CTTGA ATAGC\n   3. CGGACTTGA ATAGCC CAAAGGT TTCGACACGAT CACGACACA TAAATT GGCGGACTT GAATAGC\n                                ...\n4999. CGGAC TTGAATA GCCCAAAGGTTT CGACACGA TCACGACACAT AAATTG GCGGACTTG AATAGC\n5000. CGGACTTGAA TAGCCCA AAGGTTTCGA CACGATCAC GACACA TAAATTGGCGG ACTTGAAT AGC","category":"page"},{"location":"man/sequencing/concepts/#Subsampling-molecules-from-a-pool-1","page":"Core concepts & workflow","title":"Subsampling molecules from a pool","text":"","category":"section"},{"location":"man/sequencing/concepts/#","page":"Core concepts & workflow","title":"Core concepts & workflow","text":"DNA sequencing experiments are sampling processes, not every one of the  DNA molecules in a pool will be read by the sequencer.","category":"page"},{"location":"man/sequencing/concepts/#","page":"Core concepts & workflow","title":"Core concepts & workflow","text":"Randomly subsampling (without replacement) DNA molecules of a pool is achieved in Pseudoseq with the subsample function.","category":"page"},{"location":"man/sequencing/concepts/#Determining-the-number-of-molecules-to-subsample-1","page":"Core concepts & workflow","title":"Determining the number of molecules to subsample","text":"","category":"section"},{"location":"man/sequencing/concepts/#","page":"Core concepts & workflow","title":"Core concepts & workflow","text":"You can estimate how often a base position in the genome is represented in a DNA molecule pool using the following formula.","category":"page"},{"location":"man/sequencing/concepts/#","page":"Core concepts & workflow","title":"Core concepts & workflow","text":"C = fracLNG","category":"page"},{"location":"man/sequencing/concepts/#","page":"Core concepts & workflow","title":"Core concepts & workflow","text":"Where C is the expected coverage, L is the average length of the fragments, and N is the number of fragments, and G is the number of bases in the genome.","category":"page"},{"location":"man/sequencing/concepts/#","page":"Core concepts & workflow","title":"Core concepts & workflow","text":"If you wanted to subsample a pool such that each base position in a genome is represented ~50 times (i.e. to achieve 50x coverage), you can determine the number of fragments to subsample from the universe, by reversing the formula:","category":"page"},{"location":"man/sequencing/concepts/#","page":"Core concepts & workflow","title":"Core concepts & workflow","text":"N = fracCGL","category":"page"},{"location":"man/sequencing/concepts/#","page":"Core concepts & workflow","title":"Core concepts & workflow","text":"For example, if you wanted to sequence 250bp paired-end reads, at 50x coverage, with a genome size of 4639675bp:","category":"page"},{"location":"man/sequencing/concepts/#","page":"Core concepts & workflow","title":"Core concepts & workflow","text":"frac50 times 4639675250 = 927935","category":"page"},{"location":"man/sequencing/concepts/#","page":"Core concepts & workflow","title":"Core concepts & workflow","text":"Remembering that you get two reads from one DNA molecule with paired-end sequencing, you know to subsample 927935  2 = 463967 DNA molecules from a pool.","category":"page"},{"location":"man/sequencing/concepts/#","page":"Core concepts & workflow","title":"Core concepts & workflow","text":"tip: Tip\nPseudoseq provides a helper function that assists in this type of calculation:genome_size = 4639675\nexpected_coverage = 50\nread_length = 250\n\nN = needed_sample_size(expected_coverage, genome_size, readlength)\n\n# Divide by 2 as we're doing paired end sequencing.\ndiv(N, 2)","category":"page"},{"location":"man/sequencing/concepts/#Tagging-molecules-in-a-pool-1","page":"Core concepts & workflow","title":"Tagging molecules in a pool","text":"","category":"section"},{"location":"man/sequencing/concepts/#","page":"Core concepts & workflow","title":"Core concepts & workflow","text":"Some DNA sequencing technologies work by allowing short reads to contain longer range information by tagging molecules in a pool. The basic idea being that if two short reads come from the same large DNA molecule, they will have the same tag.","category":"page"},{"location":"man/sequencing/concepts/#","page":"Core concepts & workflow","title":"Core concepts & workflow","text":"If a DNA fragment in a universe is tagged, and then it is subsequently fragmented during a fragment transform, then all the smaller fragments derived from that long fragment will inherit that long fragment's tag. This allows shorter fragments to possess longer range information in the form of these tags, and this is the basis of 10x sequencing and similar technologies.","category":"page"},{"location":"man/sequencing/concepts/#","page":"Core concepts & workflow","title":"Core concepts & workflow","text":"Pseudoseq lets you attach tags to molecules in a pool using the tag function.","category":"page"},{"location":"man/sequencing/concepts/#.-Generating-reads-1","page":"Core concepts & workflow","title":"3. Generating reads","text":"","category":"section"},{"location":"man/sequencing/concepts/#","page":"Core concepts & workflow","title":"Core concepts & workflow","text":"Next, you generate a set of reads from your transformed pool.  Pseudoseq allows you to create paired-end sequencing reads, single-end sequencing reads, and linked paired-end sequencing reads.","category":"page"},{"location":"man/sequencing/concepts/#","page":"Core concepts & workflow","title":"Core concepts & workflow","text":"You create a set of reads using the make_reads function.","category":"page"},{"location":"man/sequencing/concepts/#","page":"Core concepts & workflow","title":"Core concepts & workflow","text":"All sequencers have a certain error rate, and so after you've created a set of reads, you can use the mark_errors function to randomly mark a set of bases in your reads that are destined to be errors in the output file.","category":"page"},{"location":"man/sequencing/concepts/#","page":"Core concepts & workflow","title":"Core concepts & workflow","text":"Finally, you use your set of reads to generate either an interleaved FASTQ file, or two FASTQ files (one for R1 reads, and one for R2 reads).","category":"page"},{"location":"man/build-a-genome/concepts/#Build-a-Genome:-*Core-concepts-and-basic-workflow*-1","page":"Build-a-Genome: Core concepts & basic workflow","title":"Build-a-Genome: Core concepts & basic workflow","text":"","category":"section"},{"location":"man/build-a-genome/concepts/#","page":"Build-a-Genome: Core concepts & basic workflow","title":"Build-a-Genome: Core concepts & basic workflow","text":"Pseudoseq allows you to plan and build genomes and chromosomes that have a certain set of features and peculiarities. The purpose for doing this is not to recreate biology perfectly. The purpose is to create genomes you understand fully (where the repeated content is, which positions are heterozygous and so on).","category":"page"},{"location":"man/build-a-genome/concepts/#","page":"Build-a-Genome: Core concepts & basic workflow","title":"Build-a-Genome: Core concepts & basic workflow","text":"Using such genomes can help you both understand and develop an intuition of what current genome assembly tools are doing, and also to help design assembly tools, and perhaps even plan sequencing experiments and form hypotheses.","category":"page"},{"location":"man/build-a-genome/concepts/#","page":"Build-a-Genome: Core concepts & basic workflow","title":"Build-a-Genome: Core concepts & basic workflow","text":"This manual includes several examples showing how to plan genomes with certain characteristics. But the core workflow, and important concepts are explained below, in 3 steps.","category":"page"},{"location":"man/build-a-genome/concepts/#.-Creating-chromosome-blueprints-1","page":"Build-a-Genome: Core concepts & basic workflow","title":"1. Creating chromosome blueprints","text":"","category":"section"},{"location":"man/build-a-genome/concepts/#","page":"Build-a-Genome: Core concepts & basic workflow","title":"Build-a-Genome: Core concepts & basic workflow","text":"Chromosome blueprints are the backbone of simulating genomes with Pseudoseq.","category":"page"},{"location":"man/build-a-genome/concepts/#","page":"Build-a-Genome: Core concepts & basic workflow","title":"Build-a-Genome: Core concepts & basic workflow","text":"Chromosome blueprints determine the nature of one chromosome in a genome.","category":"page"},{"location":"man/build-a-genome/concepts/#","page":"Build-a-Genome: Core concepts & basic workflow","title":"Build-a-Genome: Core concepts & basic workflow","text":"You can think of chromosome blueprints in Pseudoseq as: a collection of operations which, when applied to some seed sequence, result in a set of N homologous sequences.","category":"page"},{"location":"man/build-a-genome/concepts/#","page":"Build-a-Genome: Core concepts & basic workflow","title":"Build-a-Genome: Core concepts & basic workflow","text":"note: Note\nChromosome blueprints are immutable: Adding an operation to a chromosome blueprint creates a new blueprint, which is a copy of the old blueprint with the addition of the new operation.","category":"page"},{"location":"man/build-a-genome/concepts/#","page":"Build-a-Genome: Core concepts & basic workflow","title":"Build-a-Genome: Core concepts & basic workflow","text":"note: Note\nIdeally, for any chromosome blueprint you construct with Pseudoseq, for each operation is possesses, it must be possible (at least in principle) to be able to intuit what the effect of that operation will be on:The Khmer distribution produced by sequencing reads of the fabricated chromosome.\nThe structure of a sequence graph produced by sequencing reads of the fabricated chromosome.Therefore, we have made the design decision that no two operations in a chromosome blueprint may affect the same position(s) of the genome in a conflicting manner. To meet this requirement, certain operations \"consume\" a region of the chromosome planned in a blueprint. If a region is consumed, another operation that would also affect that region cannot be added to the blueprint.","category":"page"},{"location":"man/build-a-genome/concepts/#","page":"Build-a-Genome: Core concepts & basic workflow","title":"Build-a-Genome: Core concepts & basic workflow","text":"Depending on the genome, any given chromosome may be present in multiple copies. Diploids, for example have two copies of every chromosome.","category":"page"},{"location":"man/build-a-genome/concepts/#","page":"Build-a-Genome: Core concepts & basic workflow","title":"Build-a-Genome: Core concepts & basic workflow","text":"The first step in simulating any artificial genome is to create one or more blank chromosome blueprints. The plan_chrom function is used for this.","category":"page"},{"location":"man/build-a-genome/concepts/#","page":"Build-a-Genome: Core concepts & basic workflow","title":"Build-a-Genome: Core concepts & basic workflow","text":"For example, this:","category":"page"},{"location":"man/build-a-genome/concepts/#","page":"Build-a-Genome: Core concepts & basic workflow","title":"Build-a-Genome: Core concepts & basic workflow","text":"using Pseudoseq\nc = plan_chrom(100, 2)","category":"page"},{"location":"man/build-a-genome/concepts/#","page":"Build-a-Genome: Core concepts & basic workflow","title":"Build-a-Genome: Core concepts & basic workflow","text":"will create a blank blueprint for 2 copies of a chromosome of 100bp length. From the output you can see that it prints for you the number of chromosome copies, the length of the chromosomes, and a list of available, unconsumed regions of the chromosome (see note above).","category":"page"},{"location":"man/build-a-genome/concepts/#.-Adding-planned-features-to-a-chromosome-blueprint-1","page":"Build-a-Genome: Core concepts & basic workflow","title":"2. Adding planned features to a chromosome blueprint","text":"","category":"section"},{"location":"man/build-a-genome/concepts/#","page":"Build-a-Genome: Core concepts & basic workflow","title":"Build-a-Genome: Core concepts & basic workflow","text":"After creating a fresh chromosome blueprint, no plans (operations) have been added yet.","category":"page"},{"location":"man/build-a-genome/concepts/#","page":"Build-a-Genome: Core concepts & basic workflow","title":"Build-a-Genome: Core concepts & basic workflow","text":"If you were to fabricate this blank blueprint, you would get N identical DNA sequences as output, where N is the number of copies the blueprint was planning.","category":"page"},{"location":"man/build-a-genome/concepts/#","page":"Build-a-Genome: Core concepts & basic workflow","title":"Build-a-Genome: Core concepts & basic workflow","text":"Once you have one or more chromosome blueprints, you can add features to them.","category":"page"},{"location":"man/build-a-genome/concepts/#","page":"Build-a-Genome: Core concepts & basic workflow","title":"Build-a-Genome: Core concepts & basic workflow","text":"This is done with a series of consistently named plan_* functions.","category":"page"},{"location":"man/build-a-genome/concepts/#","page":"Build-a-Genome: Core concepts & basic workflow","title":"Build-a-Genome: Core concepts & basic workflow","text":"note: Note\nRemember; blueprints are immutable, so every time one of these plan_* functions is used to add a feature to a chromosome blueprint, a new chromosome blueprint is created.","category":"page"},{"location":"man/build-a-genome/concepts/#Repetitions-1","page":"Build-a-Genome: Core concepts & basic workflow","title":"Repetitions","text":"","category":"section"},{"location":"man/build-a-genome/concepts/#","page":"Build-a-Genome: Core concepts & basic workflow","title":"Build-a-Genome: Core concepts & basic workflow","text":"A repetition is a segment of a sequence, that has the exact same motif, as  another segment of the sequence.","category":"page"},{"location":"man/build-a-genome/concepts/#","page":"Build-a-Genome: Core concepts & basic workflow","title":"Build-a-Genome: Core concepts & basic workflow","text":"In Pseudoseq, to plan a repetition, you specify a region the repetition will copy, sometimes called the from region. You also specify a region where the motif in the from region will be replicated, called the to region. So you might find it helpful to imagine a planned repetition as a kind of copy-paste operation that occurs during fabricate.","category":"page"},{"location":"man/build-a-genome/concepts/#","page":"Build-a-Genome: Core concepts & basic workflow","title":"Build-a-Genome: Core concepts & basic workflow","text":"note: Note\nRepetitions consume the to region of the chromosome blueprint to which they are added. Repetitions do not consume the from region, so other operations are free to affect the motif in the from region. Just remember that the repetition will replicate anything in the from region, including other features such as heterozygosity that occur in from.","category":"page"},{"location":"man/build-a-genome/concepts/#","page":"Build-a-Genome: Core concepts & basic workflow","title":"Build-a-Genome: Core concepts & basic workflow","text":"Repetitions are added to a genome blueprint using the plan_repetition function.","category":"page"},{"location":"man/build-a-genome/concepts/#Heterozygosity-1","page":"Build-a-Genome: Core concepts & basic workflow","title":"Heterozygosity","text":"","category":"section"},{"location":"man/build-a-genome/concepts/#","page":"Build-a-Genome: Core concepts & basic workflow","title":"Build-a-Genome: Core concepts & basic workflow","text":"A heterozygosity describes a base position at which the copies of the chromosome in the blueprint differ.","category":"page"},{"location":"man/build-a-genome/concepts/#","page":"Build-a-Genome: Core concepts & basic workflow","title":"Build-a-Genome: Core concepts & basic workflow","text":"For a blueprint with 2 copies, both copies will differ at a given position.","category":"page"},{"location":"man/build-a-genome/concepts/#","page":"Build-a-Genome: Core concepts & basic workflow","title":"Build-a-Genome: Core concepts & basic workflow","text":"For a triploid, at a heterozygous position, all 3 copies might differ from each other. Alternatively, it is possible that 2 copies are the same, but they differ from a 3rd copy. This applies for blueprints with higher copy numbers too: at a heterozygous position some copies will differ from each other at that position, but some of the copies might be the same.","category":"page"},{"location":"man/build-a-genome/concepts/#","page":"Build-a-Genome: Core concepts & basic workflow","title":"Build-a-Genome: Core concepts & basic workflow","text":"note: Note\nHeterozygosity operations consume the position at which they are defined.","category":"page"},{"location":"man/build-a-genome/concepts/#","page":"Build-a-Genome: Core concepts & basic workflow","title":"Build-a-Genome: Core concepts & basic workflow","text":"Heterozygous positions are planned using the plan_het function.","category":"page"},{"location":"man/build-a-genome/concepts/#","page":"Build-a-Genome: Core concepts & basic workflow","title":"Build-a-Genome: Core concepts & basic workflow","text":"For example, below will make it so as about 50% of the two chromosome copies  are heterozygous:","category":"page"},{"location":"man/build-a-genome/concepts/#","page":"Build-a-Genome: Core concepts & basic workflow","title":"Build-a-Genome: Core concepts & basic workflow","text":"using Pseudoseq\nc = plan_chrom(100, 2)\nchet = plan_het(c, .50, 2)","category":"page"},{"location":"man/build-a-genome/concepts/#","page":"Build-a-Genome: Core concepts & basic workflow","title":"Build-a-Genome: Core concepts & basic workflow","text":"The above use of plan_het allows the function to choose which sites in the blueprint are heterozygous, and how to allocate the bases at the heterozygous sites. We only instruct the function that 50% of the genome should be heterozygous, and that there should be 2 possible bases at each position (the only option really: the blueprint plans for a diploid - 2 chromosome copies).","category":"page"},{"location":"man/build-a-genome/concepts/#","page":"Build-a-Genome: Core concepts & basic workflow","title":"Build-a-Genome: Core concepts & basic workflow","text":"You can also take more fine-grained control:","category":"page"},{"location":"man/build-a-genome/concepts/#","page":"Build-a-Genome: Core concepts & basic workflow","title":"Build-a-Genome: Core concepts & basic workflow","text":"using Pseudoseq, BioSequences\nc = plan_chrom(100, 2)\nchet = plan_het(c, 20, [DNA_T, DNA_A])","category":"page"},{"location":"man/build-a-genome/concepts/#","page":"Build-a-Genome: Core concepts & basic workflow","title":"Build-a-Genome: Core concepts & basic workflow","text":"Here I planned a heterozygous position, at one site in the chromosome (20), and I set the state of the first copy to DNA_T, and the state of the second copy to DNA_A.","category":"page"},{"location":"man/build-a-genome/concepts/#","page":"Build-a-Genome: Core concepts & basic workflow","title":"Build-a-Genome: Core concepts & basic workflow","text":"So as you can see, plan_het is very flexible. Check it's API documentation, and the \"Build-A-Yeast\" example walkthrough to see more examples of plan_het use.","category":"page"},{"location":"man/build-a-genome/concepts/#Utility-functions-1","page":"Build-a-Genome: Core concepts & basic workflow","title":"Utility functions","text":"","category":"section"},{"location":"man/build-a-genome/concepts/#","page":"Build-a-Genome: Core concepts & basic workflow","title":"Build-a-Genome: Core concepts & basic workflow","text":"There is a utility function suggest_regions available to help you plan where to place features.","category":"page"},{"location":"man/build-a-genome/concepts/#","page":"Build-a-Genome: Core concepts & basic workflow","title":"Build-a-Genome: Core concepts & basic workflow","text":"Say you wanted to see where you could place 3 5bp repetitions, you could do the following:","category":"page"},{"location":"man/build-a-genome/concepts/#","page":"Build-a-Genome: Core concepts & basic workflow","title":"Build-a-Genome: Core concepts & basic workflow","text":"r = suggest_regions(chet, 5, 6)","category":"page"},{"location":"man/build-a-genome/concepts/#","page":"Build-a-Genome: Core concepts & basic workflow","title":"Build-a-Genome: Core concepts & basic workflow","text":"So now you have 6 5bp regions, every 2 regions defining a from and a to region for a single repetition. ","category":"page"},{"location":"man/build-a-genome/concepts/#","page":"Build-a-Genome: Core concepts & basic workflow","title":"Build-a-Genome: Core concepts & basic workflow","text":"You can provide r as an input to plan_repetition.","category":"page"},{"location":"man/build-a-genome/concepts/#","page":"Build-a-Genome: Core concepts & basic workflow","title":"Build-a-Genome: Core concepts & basic workflow","text":"crep = plan_repetition(chet, r)","category":"page"},{"location":"man/build-a-genome/concepts/#","page":"Build-a-Genome: Core concepts & basic workflow","title":"Build-a-Genome: Core concepts & basic workflow","text":"Another utility function suggest_alleles is available to help you plan nucleotide patterns at heterozygous sites.","category":"page"},{"location":"man/build-a-genome/concepts/#","page":"Build-a-Genome: Core concepts & basic workflow","title":"Build-a-Genome: Core concepts & basic workflow","text":"Say you wanted to plan a pattern in which two of three chromosome copies had the same base, and a third differed.","category":"page"},{"location":"man/build-a-genome/concepts/#","page":"Build-a-Genome: Core concepts & basic workflow","title":"Build-a-Genome: Core concepts & basic workflow","text":"suggest_alleles(3, 2)","category":"page"},{"location":"man/build-a-genome/concepts/#","page":"Build-a-Genome: Core concepts & basic workflow","title":"Build-a-Genome: Core concepts & basic workflow","text":"The above asks for an allele pattern for 3 copies of a chromosome, with 2 possible alleles, which chromosome copy gets which allele is random.","category":"page"},{"location":"man/build-a-genome/concepts/#","page":"Build-a-Genome: Core concepts & basic workflow","title":"Build-a-Genome: Core concepts & basic workflow","text":"You can also take more control and specify which chromosome copy gets which state:","category":"page"},{"location":"man/build-a-genome/concepts/#","page":"Build-a-Genome: Core concepts & basic workflow","title":"Build-a-Genome: Core concepts & basic workflow","text":"suggest_alleles(chet, [1, 1, 2])\n# Or alternatively put:\nsuggest_alleles(chet, [1, 2], [3])","category":"page"},{"location":"man/build-a-genome/concepts/#","page":"Build-a-Genome: Core concepts & basic workflow","title":"Build-a-Genome: Core concepts & basic workflow","text":"In the above, which chromosomes get the same allele is user-specified, but which bases those alleles are, is randomly determined.","category":"page"},{"location":"man/build-a-genome/concepts/#","page":"Build-a-Genome: Core concepts & basic workflow","title":"Build-a-Genome: Core concepts & basic workflow","text":"You can get many suggestions at once:","category":"page"},{"location":"man/build-a-genome/concepts/#","page":"Build-a-Genome: Core concepts & basic workflow","title":"Build-a-Genome: Core concepts & basic workflow","text":"suggest_alleles(5, [1, 1, 2])","category":"page"},{"location":"man/build-a-genome/concepts/#","page":"Build-a-Genome: Core concepts & basic workflow","title":"Build-a-Genome: Core concepts & basic workflow","text":"See the API docs for suggest_alleles for more details on the arguments permitted by the different methods. ","category":"page"},{"location":"man/build-a-genome/concepts/#.-Fabricate-a-FASTA-from-chromosome-blueprints-1","page":"Build-a-Genome: Core concepts & basic workflow","title":"3. Fabricate a FASTA from chromosome blueprints","text":"","category":"section"},{"location":"man/build-a-genome/concepts/#","page":"Build-a-Genome: Core concepts & basic workflow","title":"Build-a-Genome: Core concepts & basic workflow","text":"Once you have a set of chromosome blueprints with the features planned that you desire, you can fabricate the sequences of these chromosomes.","category":"page"},{"location":"man/build-a-genome/concepts/#","page":"Build-a-Genome: Core concepts & basic workflow","title":"Build-a-Genome: Core concepts & basic workflow","text":"To do that, use the fabricate method.","category":"page"},{"location":"man/build-a-genome/concepts/#","page":"Build-a-Genome: Core concepts & basic workflow","title":"Build-a-Genome: Core concepts & basic workflow","text":"You can simply fabricate the sequences, for use in the interactive session:","category":"page"},{"location":"man/build-a-genome/concepts/#","page":"Build-a-Genome: Core concepts & basic workflow","title":"Build-a-Genome: Core concepts & basic workflow","text":"fabricate(chet)","category":"page"},{"location":"man/build-a-genome/concepts/#","page":"Build-a-Genome: Core concepts & basic workflow","title":"Build-a-Genome: Core concepts & basic workflow","text":"Or have the sequences output to a FASTA formatted file.","category":"page"},{"location":"man/build-a-genome/concepts/#","page":"Build-a-Genome: Core concepts & basic workflow","title":"Build-a-Genome: Core concepts & basic workflow","text":"fabricate(\"mychrom.fasta\", chet)","category":"page"},{"location":"man/build-a-genome/concepts/#","page":"Build-a-Genome: Core concepts & basic workflow","title":"Build-a-Genome: Core concepts & basic workflow","text":"A randomly generated seed sequence is used to start the fabrication process unless you provide one. See the API docs for fabricate for more details.","category":"page"},{"location":"man/build-a-genome/concepts/#","page":"Build-a-Genome: Core concepts & basic workflow","title":"Build-a-Genome: Core concepts & basic workflow","text":"And that's all there is to building a chromosome with Pseudoseq. To build a genome with more than one chromosome, simply build a set of chromosome blueprints.","category":"page"},{"location":"man/build-a-genome/concepts/#","page":"Build-a-Genome: Core concepts & basic workflow","title":"Build-a-Genome: Core concepts & basic workflow","text":"Now check out the examples to see how various genomes can be built with Pseudoseq.","category":"page"},{"location":"api/chromosome-blueprint/#API:-Build-a-Genome-1","page":"Build-a-Genome","title":"API: Build-a-Genome","text":"","category":"section"},{"location":"api/chromosome-blueprint/#Exported-functions-1","page":"Build-a-Genome","title":"Exported functions","text":"","category":"section"},{"location":"api/chromosome-blueprint/#Making-an-empty-chromosome-blueprint-1","page":"Build-a-Genome","title":"Making an empty chromosome blueprint","text":"","category":"section"},{"location":"api/chromosome-blueprint/#","page":"Build-a-Genome","title":"Build-a-Genome","text":"plan_chrom","category":"page"},{"location":"api/chromosome-blueprint/#Planning-motif-repetitions-along-chromosomes-1","page":"Build-a-Genome","title":"Planning motif repetitions along chromosomes","text":"","category":"section"},{"location":"api/chromosome-blueprint/#","page":"Build-a-Genome","title":"Build-a-Genome","text":"plan_repetition","category":"page"},{"location":"api/chromosome-blueprint/#Planning-heterozygosity-between-chromosome-copies-1","page":"Build-a-Genome","title":"Planning heterozygosity between chromosome copies","text":"","category":"section"},{"location":"api/chromosome-blueprint/#","page":"Build-a-Genome","title":"Build-a-Genome","text":"plan_het","category":"page"},{"location":"api/chromosome-blueprint/#Fabricate-1","page":"Build-a-Genome","title":"Fabricate","text":"","category":"section"},{"location":"api/chromosome-blueprint/#","page":"Build-a-Genome","title":"Build-a-Genome","text":"fabricate","category":"page"},{"location":"api/chromosome-blueprint/#Utility-functions-1","page":"Build-a-Genome","title":"Utility functions","text":"","category":"section"},{"location":"api/chromosome-blueprint/#","page":"Build-a-Genome","title":"Build-a-Genome","text":"suggest_regions\nsuggest_alleles","category":"page"},{"location":"api/reads/#API:-Reads-1","page":"Reads","title":"API: Reads","text":"","category":"section"},{"location":"api/reads/#Exported-functions-1","page":"Reads","title":"Exported functions","text":"","category":"section"},{"location":"api/reads/#Making-reads-1","page":"Reads","title":"Making reads","text":"","category":"section"},{"location":"api/reads/#","page":"Reads","title":"Reads","text":"make_reads","category":"page"},{"location":"api/reads/#Introducing-errors-1","page":"Reads","title":"Introducing errors","text":"","category":"section"},{"location":"api/reads/#","page":"Reads","title":"Reads","text":"mark_errors","category":"page"},{"location":"api/reads/#Generating-FASTQ-files-1","page":"Reads","title":"Generating FASTQ files","text":"","category":"section"},{"location":"api/reads/#","page":"Reads","title":"Reads","text":"generate","category":"page"},{"location":"#Pseudoseq-1","page":"Home","title":"Pseudoseq","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Fake genomes, fake sequencing, real insights.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"(Image: Latest Release) (Image: MIT license) (Image: Stable) (Image: Latest) (Image: Pkg Status) (Image: DOI)","category":"page"},{"location":"#Description-1","page":"Home","title":"Description","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The Pseudoseq package allows you to build arbitrary genomes, and simulate DNA sequencing experiments. DNA sequencing experiments are modelled conceptually as a sampling process.","category":"page"},{"location":"#Install-1","page":"Home","title":"Install","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Pseudoseq is built with BioJulia, and is designed with compatibility with the BioJulia ecosystem of tools in mind. Pseudoseq is made available to install through BioJulia's package registry.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Julia by default only watches the \"General\" package registry, so before you start, you should add the BioJulia package registry.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Start a julia terminal, hit the ] key to enter pkg mode (you should see the prompt change from julia> to pkg>), then enter the following command:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"registry add https://github.com/BioJulia/BioJuliaRegistry.git","category":"page"},{"location":"#","page":"Home","title":"Home","text":"After you've added the registry, you can install Pseudoseq from the julia REPL. Press ] to enter pkg mode again, and enter the following:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"add Pseudoseq","category":"page"},{"location":"#Testing-1","page":"Home","title":"Testing","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Pseudoseq is tested against Julia 1.X on Linux, OS X, and Windows.","category":"page"}]
}
